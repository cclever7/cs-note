<center><font size = 45>设计模式</font></center>

参考：https://blog.csdn.net/liang19890820/article/details/66974516

## 设计模式原则

1. **1、开闭原则（Open Close Principle）**

   开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

   **2、里氏代换原则（Liskov Substitution Principle）**

   里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

   **3、依赖倒转原则（Dependence Inversion Principle）**

   这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

   **4、接口隔离原则（Interface Segregation Principle）**

   这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

   **5、迪米特法则（最少知道原则）（Demeter Principle）**

   为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

   **6、合成复用原则（Composite Reuse Principle）**

   原则是尽量使用合成/聚合的方式，而不是使用继承



## 设计模式的类型

共有 23 种设计模式，这些模式可以分为三类：

| 类型                              | 描述                                           |
| --------------------------------- | ---------------------------------------------- |
| 创建型模式（Creational Patterns） | 用于构建对象，以便它们可以从实现系统中分离出来 |
| 结构型模式（Structural Patterns） | 用于在许多不同的对象之间形成大型对象结构       |
| 行为型模式（Behavioral Patterns） | 用于管理对象之间的算法、关系和职责             |

#### 创建型模式

单例模式（Singleton Pattern）
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

抽象工厂模式 （Abstract Factory Pattern）
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

建造者模式（Builder Pattern）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

工厂方法模式 （Factory Method Pattern）
定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。

原型模式（Prototype Pattern）
用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

结构型模式
适配器模式（Adapter Pattern）
将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

桥接模式（Bridge Pattern）
将抽象部分与它的实现部分分离，使它们都可以独立地变化。

装饰者模式（Decorator Pattern）
动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。

组合模式（Composite Pattern）
将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。

外观模式（Facade Pattern）
为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

享元模式（Flyweight Pattern）
运用共享技术有效地支持大量细粒度的对象。

代理模式（Proxy Pattern）
为其他对象提供一个代理以控制对这个对象的访问。

行为型模式
模版方法模式 （Template Method Pattern）
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

命令模式（Command Pattern）
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

迭代器模式（Iterator Pattern）
提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

观察者模式（Observer Pattern）
定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

中介者模式（Mediator Pattern）
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

备忘录模式 （Memento Pattern）
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

解释器模式（Interpreter Pattern）
给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

状态模式（State Pattern）
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

策略模式（Strategy Pattern）
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户端。

职责链模式 （Chain of Responsibility Pattern）
为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

访问者模式 （Visitor Pattern）
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作



普及

## 常用的设计模式

#### 单例模式

单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。**单例模式下可以确保某一个类只有一个实例**，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。C++的实现有两种，一种通过局部静态变量，利用其只初始化一次的特点，返回对象。另外一种，则是定义全局的指针，getInstance判断该指针是否为空，为空时才实例化对象

#### 工厂模式

工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。

#### 观察者模式

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

#### 装饰器模式

**意图**：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。

#### 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

#### 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

#### 模板模式

在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。













