## 数据库完整性

**数据库完整性**是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。**数据库完整性由各种各样的完整性约束来保证**

1. **实体完整性**：实体完整性指表中行的完整性。主要用于保证操作的数据（记录）非空、唯一且不重复。

2. **参照完整性**：属于表间规则，对于永久关系的相关表，在更新、插入或删除记录时，如果只改其一，就会影响数据的完整性。

3. **用户定义(域)完整性**：是指数据库表中的列必须满足某种特定的数据类型或约束。其中约束又包括取值范围、精度等规定。表中的CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL定义都属于域完整性的范畴。

   

## 事务

事务指的是满足 ACID 特性的一组操作，要么全部执行，要么不执行，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

##### ACID

1. **原子性**：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
2. **一致性**：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
3. **隔离性**：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. **持久性**：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

##### 事务的 ACID关系

1. 只有满足一致性，事务的执行结果才是正确的。

2. 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。

3. 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。

4. 事务满足持久化是为了能应对系统崩溃的情况。

   

## 并发一致性问题

1. **丢失修改**：指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

2. **读脏数据**：指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

3. **不可重复读**：指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

4. **幻读**：本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

   

## 隔离级别

1. **未提交读**：事务中的修改，即使没有提交，对其它事务也是可见的。
2. **提交读**：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
3. **可重复读**：保证在同一个事务中多次读取同一数据的结果是一样的。
4. **可串行化**：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行

## 封锁

##### 封锁粒度

封锁粒度主要有两种，**行级锁、表级锁**。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

##### 封锁类型

1. **读写锁**

   互斥锁（Exclusive），简写为 X 锁，又称写锁。

   共享锁（Shared），简写为 S 锁，又称读锁

2. **意向锁**

   使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

   意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

   - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁
   - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁



## 关系数据库设计理论

##### 函数依赖：

1. 函数依赖：记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。
2. 部分函数依赖：对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。
3. 传递函数依赖：对于 A->B，B->C，则 A->C 是一个传递函数依赖。

##### 范式

1. 第一范式 (1NF):属性不可分。
2. 第二范式 (2NF):每个非主属性完全函数依赖于键码。
3. 第三范式 (3NF):非主属性不传递函数依赖于键码

#####  ER 图

组成：实体、属性、联系。

##### 实体的三种联系:

包含一对一，一对多，多对多三种。