<center><font size = 45>C++基础</font></center>

## 基础知识

#### RTTI

Run-Time Type Identification,运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info



## 数据类型

#### 基本数据类型

| **数据类型** | **占用空间**                                    | 取值范围         |
| ------------ | ----------------------------------------------- | ---------------- |
| short        | 2字节                                           | (-2^15 ~ 2^15-1) |
| int          | 4字节                                           | (-2^31 ~ 2^31-1) |
| long         | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long    | 8字节                                           | (-2^63 ~ 2^63-1) |
| float        | 4字节                                           | 7位有效数字      |
| double       | 8字节                                           | 15～16位有效数字 |
| char         | 1字节                                           |                  |
| bool         | 1字节                                           |                  |
| pointer      | 4字节                                           |                  |
| void         |                                                 |                  |

#### 数据类型转换

##### 隐式类型转换

隐式转换指的是不需要用户干预，编译器私下进行的类型转换行为。对于**内置类型**，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在**单个参数的构造函数的对象构造来说**，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象

**C++中四种类型转换是**：` const_cast, static_cast, dynamic_cast, reinterpret_cast`

1. **const_cast：**用于将const变量转为非const
2. **static_cast ：**用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
   - 向上转换：指的是子类向基类的转换
   - 向下转换：指的是基类向子类的转换
3. **dynamic_cast：**用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
4. **reinterpret_cast：**几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

## 关键字 

**关键字**是C++中预先保留的单词（标识符）

| asm        | do           | if               | return      | typedef  |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

#### sizeof

`sizeof(object/type_name)`其作用是返回一个对象或类型所占的内存字节数。其是**关键字也是操作符不是函数**，类似于`++ -- >=...`

1. 结构体`sizeof`：涉及到字节对齐问题。、

   未展开

2. 数组`sizeof`值：等于数组所占用的内存字节数

3. 指针`sizeof`：指针是用来记录另一个对象的地址，所以指针的内存大小等于计算机内部地址总线的宽度。在32位计算机中指针变量的返回值必定是4。

#### const

1. 修饰变量，`const  数据类型 常量名 = 常量值`,修饰变量常量，该值不可以改变
2. 修饰指针存在三种情况
   1. 修饰指针 `const int *p = &a`，此时指针指向可以改变，值不可以变，修饰的为`int *`
   2. 修饰常量`int * const p = &a` ，此时指针指向不可以变，值可以改变 ，修饰的为`p`
   3. 既修饰常量，又修饰指针`const int * const p = &a`，此时都不可改变
3. const修饰成员函数，表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

#### static

1. **修饰普通变量**，分为全局和局部，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. **修饰普通函数**，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. **修饰成员变量**，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. **修饰成员函数**，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

#### inline

1. 相当于把内联函数里面的内容写在调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，却比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

#### new、delete

**new**：在堆区开辟空间，返回地址即该数据对应的类型的指针，**delete**：释放空间

若使用**new[]**开辟空间，则对应需要**delete[]**释放空间

#### extern “C”

C++调用C函数需要extern C，因为C语言没有函数重载。

## 数组

#### 一维数组

定义 `数据类型 数组名[] = {值1, 2}`

#### 二维数组

定义 `数据类型 数组名[][列数] = {值1, 2, 3, 4}`

#### 指针数组、



#### 数组指针



## 函数

#### 函数重载

函数名可以相同，函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**，返回值不可以作为函数重载的条件

**注意**

1. 引用可作为重载条件

   ```c++
   func(int &a){}
   func(const int &a){}
   ```

2. 函数重载碰到函数默认参数，可能会产生歧义需要避免

#### 函数指针

1. ##### 定义

**函数指针是指向函数的指针变量。**函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

2. ##### 用途：

调用函数和做函数的参数，比如回调函数。

3. ##### 示例：

```c++
char * fun(char * p) {…}    // 函数fun
char * (*pf)(char * p);       // 函数指针pf
pf = fun;            // 函数指针pf指向函数fun
pf(p);            // 通过函数指针pf调用函数fun
```

#### 字符串操作函数

1. strcpy
2. strlen
3. strcat
4. strlen
5. strcmp
6. strchr
7. strpbrk
8. strspn
9. strcspn

#### 其它函数

1. ##### fork,wait,exec

   创建一个和当前进程映像一样的进程可以通过fork( )系统调用。父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个二进制文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

2. ##### select

   select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大

3. ##### epoll, poll

   首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。



## 指针

**指针的作用：** 可以通过指针间接访问内存，指针的大小是4(sizeof)。野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针

#### 智能指针

智能指针的作用是管理一个指针，可以避免申请的空间在函数结束时忘记释放，造成内存泄漏。C++里面的四个智能指针: `auto_ptr, shared_ptr, weak_ptr, unique_ptr`其中后**三个是c++11支持**，并且**第一个已经被C++11弃用**

##### 原理

**智能指针就是一个类**，当超出了类的作用域类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1. **auto_ptr**（c++98的方案，cpp11已经抛弃）

   采用所有权模式。`p2 = p1`，p2剥夺p1的所有权当程序运行时访问p1将会报错。因此其存在潜在的内存崩溃问题

2. **unique_ptr**（替换auto_ptr）

   

3. **shared_ptr**

   它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源

4. **weak_ptr**

   

#### 智能指针有没有内存泄露

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

#### 内存泄漏如何解决

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。



## 引用

给变量起别名，**语法：**`数据类型 &别名 = 原名`

1. 一旦初始化后，值不可以改变

2. 

   ```c++
   
   ```

3. 引用做函数参数

   ```c++
   
   ```

4. 引用做函数返回值，不可返回局部变量引用

   ```c++
   
   ```

**引用的本质**在c++内部实现是一个指针常量`int * const p = &a`

**常量引用：**`const int &v`



## 指针与引用的区别

##### 引用

C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用`&`代替了`*`。

##### 指针

指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

##### 区别

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
5. 可以有const指针，但是没有const引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7. 指针可以有多级指针（**p），而引用至于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

## 文件操作

#### 文件类型

1. **文本文件** - 文件以文本的**ASCII码形式存储在计算机中**
2. **二进制文件** - 文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们

#### 操作文件的类



#### 打开方式

| os::in             | 为读文件而打开文件 |
| ------------------ | ------------------ |
|                    |                    |
| ios::out           |                    |
| 为写文件而打开文件 |                    |
| ios::ate           |                    |
| 初始位置：文件尾   |                    |



#### 读文件



#### 写文件





## C++ 11























