<center><font size=45>面向对象</font></cetner>

C++面向对象的三大特性为：**封装、继承、多态**

**类和对象**的理解：类是某种类型的事物的特征表现，对象是类的实例，万事万物都皆为对象，对象上有其属性和行为



## 类(class)

**类**是某一种类型的事物的特征表现，语法：`class 类名{访问权限：属性/方法};`

**构造函数与析构函数：**默认情况下，c++编译器至少给一个类添加3个函数，**默认构造函数**，**默认析构函数**，**默认拷贝构造函数（对属性进行值拷贝**），如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造，如果用户定义拷贝构造函数，c++不会再提供其他构造函数

#### 成员

**分类**：成员包括**成员变量和成员函数**

**空间占用**：类内的成员变量和成员函数**分开存储**，只有**非静态成员变量**才属于类的对象上占用对象空间，函数和静态成员不占对象空间。

**const修饰成员：**成员函数后加const后我们称为这个函数为**常函数**，常函数内不可以修改成员属性，但成员属性声明时加**关键字mutable**后，在常函数中依然可以修改。声明对象前加const称该对象为常对象常对象只能调用常函数

#### 构造函数

主要作用在于**创建对象**时为对象的**成员属性赋值**，编译器默认提供构造函数（空实现）

1. **语法：**`类名(){}`，其函数名称与类名相同，没有返回值也不写void，可以有参数可发生重载

2. **分类**

   1. 有参构造和无参构造

   2. 普通构造和拷贝构造 

      ```c++
      Person(const Person &p){	//拷贝构造
          this->age = p.age;
      }
      ```

3. **调用方式**

   1. 显示法：`Person p = Person(10);`
   2. 括号法：`Person p1(10);`, 
   3. 隐式转换法`Person p1 = 10; // 就是Person p = Person(10);`

   特别地：**无参构造函数不能加括号**，加了编译器认为这是一个函数声明；**不能利用拷贝构造函数初始化匿名对象**

4. **初始化方式**

   **语法：** `构造函数(参数1, 参数2, ...)：属性1(参数1),属性2（参数2）... {}`

   ```c++
   Person(int a, int b, int c):m_a(a), m_b(b), m_c(c){}
   ```

#### 析构函数

主要作用在于对象**销毁前**系统自动调用，执行一些清理工作

1. 语法：`~类名(){}`其函数名称与类名相同前面加上`~`符号`，没有返回值也不写void，可以有参数可发生重载
2. 虚析构和纯虚析构
3. 1
4. 1
5. 1
6. 1



#### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员，也称类成员。调用`类名::静态成员`，不需要创建实例对象

1. 静态成员变量：所有对象共享同一份数据；在编译阶段分配内存；类内声明，类外初始化
2. 静态成员函数：所有对象共享同一个函数；静态成员函数只能访问静态成员变量

#### this指针

1. **this指针**指向被调用的成员函数所属的对象
2. **作用：**
   1. 当形参和成员变量同名时，可用this指针来区分
   2. 在类的非静态成员函数中返回对象本身，可**使用return *this**

#### 其它

1. ##### struct与class的区别

   在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**，区别：struct 默认权限为公共，class 默认权限为私有。

2. ##### 深拷贝与浅拷贝

   **浅拷贝**：简单的赋值拷贝操作； **深拷贝**：在堆区重新申请空间，进行拷贝操作

3. **空指针对象调用** 

   空指针，可以调用成员函数，但是如果成员函数中用到了this指针，就不可以了

   ```c++
   void method{
       Person *p = NULL;
       p->methodName(); // 空指针，可以调用成员函数
   }
   
   ```

   

## 友元类

友元的目的就是让一个函数或者类**访问另一个类中私有成员**，关键字`friend`

友元的**三种实现**：**全局函数做友元，类做友元，成员函数做友元**

1. **全局函数做友元**

   ```c++
   public class Clazz{
       friend void friendMethod(Clazz *clazz);
   private:
       string value;
   };
   void friendMethod(Clazz *clazz){
       cout << clazz->value << endl;
   }
   ```

2. **类做友元**

3. **成员函数做友元**

​	

#### 运算符重载

运算符重载概念：**对已有的运算符重新进行定义**，赋予其另一种功能，以适应不同的数据类型1

1. **加号运算符重载**
2. **移位运算符重载**
3. **递增运算符重载**
4. **赋值运算符重载**
5. **关系运算符重载**
6. **调用 运算符重载**

## 封装

##### 访问权限

1. public 
2. protected
3. private

## 继承

下级别的成员除了拥有上一级的共性，还有自己的特性。**可以减少重复的代码**

**语法：**`class 子类 : 继承方式 父类;`

**继承模型**：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到

**构造与析构：**继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反

**同名成员：**

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中

##### 继承方式

	1. 公共继承
 	2. 保护继承
 	3. 私有继承

**多继承**

`class 子类 ：继承方式 父类1 ， 继承方式 父类2...`，多继承可能会引发父类中有同名成员出现，需要加作用域区分

**菱形继承**

菱形继承带来的主要问题是子类继承两份相同的数据，利用虚继承可以解决菱形继承问题

`class Sheep : virtual public Animal {};`

## 多态

**多态分类：**

1. **静态多态：** 函数重载和运算符重载属于静态多态，复用函数名，编译阶段确定函数地址

2. **动态多态：** 派生类和虚函数实现运行时多态， 运行阶段确定函数地址。有继承关系，子类重写父类中的虚函数同，父类指针或引用指向子类对象

   ```c++
   class Animal{
   public:
       virtual void speak(){
           cout << "animal speak" << endl;
       }
   };
   class Cat : public Animal{
   public:
       void speak(){
           cout << "cat speak" << endl;
       }
   }
   int main(){
       Animal *animal = new Cat();
       animal->speak(); // cout << cat speak << endl;
       delete animal;
   }
   ```

## 抽象类

`语法：virtual 返回值类型 函数名 （参数列表）= 0 ;`

通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为**纯虚函数**。当类中有了纯虚函数，这个类也称为**抽象类**

**特点：**

1. 无法实例化对象
2. 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

##### 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，将父类中的析构函数改为**虚析构**或者**纯虚析构**

1. **相同点：**用来解决通过父类指针释放子类对象
2. **区别：**
   - 虚析构语法：`virtual ~类名(){}`
   - 纯虚析构语法：`virtual ~类名() = 0; `
   - 如果是纯虚析构，该类属于抽象类，无法实例化对象









## 模板

